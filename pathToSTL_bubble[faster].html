<!DOCTYPE html>
<html>

<head>
    <style>
        path:first-child {
            stroke: #000;
            stroke-width: .1;
            fill: none;
        }
    </style>
</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="-50 -50 100 100">
        <path />
    </svg>
    <script>
        const $ = (s, p = document) => p.querySelector(s);
        const svg = $('svg');
        const path = $('path', svg);
        var mat3D = [];
        var points = [];
        // var lines = [];
        var str = "";
        var precision = 10;
        var rotate_precision = 50;
        var r = 10;
        var angle = 0;
        Object.defineProperties(Array.prototype, {
            add: {
                value: function (...arrs) {
                    console.log(this, arrs)
                    arrs.forEach(arr => {
                        for (let i = 0; i < this.length; i++) {
                            this[i] += arr[i]
                        }
                    });
                    return this;
                }
            },
            multiply: {
                value: function (n) {
                    for (let i = 0; i < this.length; i++) {
                        this[i] *= n;
                    }
                    return this;
                }
            },
            sum: {
                value: function () {
                    if (typeof this[0] === "number") return this.reduce((s, p) => s + p);
                    return this[0].add(...this.splice(1, this.length - 1));
                }
            },
            last: {
                get: function () {
                    return this[this.length - 1]
                }
            },
            clone: {
                get: function () {
                    const a = [];
                    for (let i in this) a[i] = this[i];
                    return a;
                }
            },
            dMap: {
                value: function (callback) {
                    for (let i in this) this[i] = callback(this[i], Number(i));
                    return this;
                }
            },
            norm: { get: function () { return Math.hypot(...this); } },
            setNorm: {
                value: function (n) {
                    const N = this.norm;
                    if (N === 0) return false;
                    this.dMap(e => e * n / N);
                    return this
                }
            }
        });
        function sum(k, n, fn) { return new Array(n - k + 1).fill(0).map((i, j) => fn(j)).sum() }
        function binomialcoefs(n) {
            if (n === 0) return [1]
            const previous = binomialcoefs(n - 1);
            return [1, ...new Array(n - 1).fill(0).map((e, i) => previous[i] + previous[i + 1]), 1];
        }
        const bez = [];
        function BezierCurve(...pts) {
            bez.push(this);
            this.pts = pts;
            this.n = pts.length - 1;
            this.getPoints = n => new Array(n).fill(0).map((i, j) => this.fn((j + 1) / n))
        }
        function Line(A, B) {
            this.pts = [A, B];
            this.getPoints = n => (console.log(this.pts), [this.pts[1]])
            this.derivative = () => [A[0] - B[0], A[1] - B[1]].setNorm(1)
        }
        var run = () => {
            str2 = '';
            if (points.length === 0) return
            const v = [...points[0], ...points[0]]
            for (let i in points) {
                point = points[i]
                console.log(i, point)
                if (v[0] > point[0]) v[0] = point[0]
                else if (v[2] < point[0]) v[2] = point[0]
                if (v[1] > point[1]) v[1] = point[1]
                else if (v[3] < point[1]) v[3] = point[1];
                str2 += (i !== "0" ? ' L ' : 'M ') + point[0] + ',' + point[1];
            }
            console.log(points)
            v[2] -= v[0];
            v[3] -= v[1];
            svg.setAttribute('viewBox', `${v.join(' ')}`)
            path.setAttribute('d', str2);
        }
        String.prototype.splice = function (index, rem, str) {
            return this.slice(0, index) + str + this.slice(index + Math.abs(rem));
        };
        function numbertoSTL(n) {
            if (n === 0) return '0.00000E+000';
            const s = Math.sign(n);
            const k = Math.floor(Math.log10(Math.abs(n)));
            n *= 10 ** -k;
            n = (Math.round(n * 1e5) * 1e-5).toString()
            if (n.length === (s === -1 ? 2 : 1)) n += '.00000';
            else for (let i = n.length; i < (s === -1 ? 8 : 7); i++) n += '0';
            var k_txt = Math.abs(k).toString();
            while (k_txt.length < 3) k_txt = '0' + k_txt;
            console.log(k_txt)
            return `${n.slice(0, (s === -1 ? 8 : 7))}E${k < 0 ? '-' : '+'}${k_txt}`
        }
        const vertexText = point => `            vertex ${point.map(numbertoSTL).join(' ')}`;
        function crossProduct(v, u) { return [v[1] * u[2] - v[2] * u[1], v[2] * u[0] - v[0] * u[2], v[0] * u[1] - v[1] * u[0]] }
        function normalVector(A, B, C) { return crossProduct([A[0] - B[0], A[1] - B[1], A[2] - B[2]], [A[0] - C[0], A[1] - C[1], A[2] - C[2]]) }
        function toSTL() {
            var str = `solid svgobject\n`
            const t = "    ";
            const Txt = mat3D.map(e => e.map(i => vertexText(i)));
            for (let i = 0; i < points.length - 1; i++) {
                for (let j = 0; j < rotate_precision + 1; j++) {
                    const A = mat3D[i][j],
                        B = mat3D[i][(j + 1) % (rotate_precision + 1)],
                        C = mat3D[i + 1][j],
                        D = mat3D[i + 1][(j + 1) % (rotate_precision + 1)];
                    const txtA = Txt[i][j], txtB = Txt[i][(j + 1) % (rotate_precision + 1)], txtC = Txt[i + 1][j], txtD = Txt[i + 1][(j + 1) % (rotate_precision + 1)];
                    str += `${t}facet normal ${normalVector(A, B, C).map(numbertoSTL).join(' ')}\n${t + t}outer loop\n${txtA}\n${txtB}\n${txtC}\n${t + t}endloop\n${t}endfacet\n`
                    str += `${t}facet normal ${normalVector(C, B, D).map(numbertoSTL).join(' ')}\n${t + t}outer loop\n${txtC}\n${txtB}\n${txtD}\n${t + t}endloop\n${t}endfacet\n`
                }
            }
            str += `endsolid svgobject`;
            return str;
        }
        function getTube(point, derivative) {
            return new Array(rotate_precision + 1).fill(0).map((_, i) => [point[0] + -derivative[1] * r * Math.cos(Math.PI * i / rotate_precision + angle), point[1] + derivative[0] * r * Math.cos(Math.PI * i / rotate_precision + angle), r * Math.sin(Math.PI * i / rotate_precision + angle)])
        }
        function readSVG(str, scale = 1) {
            const sp = str.split(/[\s,]+/);
            const divide = [];
            var i = 0;
            var relativity;
            var type = "";
            while (i < sp.length) {
                if (isNaN(sp[i])) {
                    type = sp[i].toLowerCase();
                    relativity = type === sp[i];
                    i++;
                } else {
                    const pt = relativity ? divide.last?.last || [0, 0] : [0, 0];
                    switch (type) {
                        case "m":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])].multiply(scale).add(pt)]);
                            type = "l"
                            i += 2;
                            break;
                        case "l":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])].multiply(scale).add(pt)]);
                            i += 2;
                            break;
                        case "h":
                            divide.push([[Number(sp[i]) * scale + pt[0], divide.last?.last?.[1] || 0]]);
                            i += 1;
                            break;
                        case "v":
                            divide.push([[divide.last?.last?.[0] || 0, Number(sp[i]) * scale + pt[1]]]);
                            i += 1;
                            break;
                        case "c":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])], [Number(sp[i + 2]), Number(sp[i + 3])], [Number(sp[i + 4]), Number(sp[i + 5])]].map(e => e.multiply(scale).add(pt)));
                            i += 6;
                            break;
                        case "q":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])], [Number(sp[i + 2]), Number(sp[i + 3])]].map(e => e.multiply(scale).add(pt)));
                            i += 4;
                            break;
                    }
                }
            }
            console.log(divide)
            points = [divide[0][0]];
            derivatives = [[divide[1][0][0] - divide[0][0][0], divide[1][0][1] - divide[0][0][1]].setNorm(1)];
            mat3D = [getTube(points[0], derivatives[0])];
            for (let i = 1; i < divide.length; i++) {
                if (divide[i].length === 1) {
                    points.push(pt = divide[i][0])
                    derivatives.push(d = [divide[i][0][0] - divide[i - 1].at(-1)[0], divide[i][0][1] - divide[i - 1].at(-1)[1]].setNorm(1));
                    mat3D.push(getTube(pt, d));
                } else {
                    const n = divide[i].length;
                    const pts = [divide[i - 1].last, ...divide[i]];
                    const cs = binomialcoefs(n);
                    for (let j = 0; j < precision; j++) {
                        if (j === precision - 1) {
                            points.push(pt = divide[i].last);
                            derivatives.push(d = [divide[i].at(-1)[0] - divide[i].at(-2)[0], divide[i].at(-1)[1] - divide[i].at(-2)[1]].setNorm(1));
                            mat3D.push(getTube(pt, d));
                            break;
                        }
                        const a = (j + 1) / precision;
                        const b = 1 - a;
                        console.log(pts)
                        pt = sum(0, n, function (i) { return pts[i].clone.multiply(cs[i] * a ** i * b ** (n - i)) });
                        points.push(pt);
                        d = sum(0, n, function (i) { return pts[i].clone.multiply(cs[i] * a ** i * b ** (n - i) * (i / a - (n - i) / b)) }).setNorm(1);
                        derivatives.push(d);
                        mat3D.push(getTube(pt, d));
                    }
                }
            }
        }
        onkeydown = (e) => {
            const { key, ctrlKey, shiftKey } = e;
            if (ctrlKey) {
                if (key.toLowerCase() === 's') {
                    e.preventDefault()
                    const a = document.createElement('a');
                    a.href = 'data:image/svg+xml;utf-8,' + encodeURIComponent(toSTL());
                    a.download = `path.stl`;
                    a.click();
                }
                if (key.toLowerCase() === 'e') {
                    e.preventDefault()
                    str = prompt('str', str) || str;
                    precision = Number(prompt('precision', precision) || precision);
                    rotate_precision = Number(prompt('rotate precision', rotate_precision) || rotate_precision);
                    r = Number(prompt('radius', r) || r);
                    readSVG(str, Number(prompt("current scale: (number)", 0.26458333) || 1));
                    run()
                    angle = Number(prompt('angle', angle) || angle)*Math.PI/180;
                }
            }
        }
        run()
    </script>
</body>

</html>