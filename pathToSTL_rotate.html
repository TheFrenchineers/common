<!DOCTYPE html>
<html>

<head>
    <style></style>
</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="-50 -50 100 100">
        <path />
    </svg>
    <script>
        const $ = (s, p = document) => p.querySelector(s);
        const svg = $('svg');
        const path = $('path', svg);
        var points = [];
        var lines = [];
        var str = "";
        var precision = 10;
        var rotate_precision = 50;
        Object.defineProperties(Array.prototype, {
            add: {
                value: function (...arrs) {
                    console.log(this, arrs)
                    arrs.forEach(arr => {
                        for (let i = 0; i < this.length; i++) {
                            this[i] += arr[i]
                        }
                    });
                    return this;
                }
            },
            multiply: {
                value: function (n) {
                    for (let i = 0; i < this.length; i++) {
                        this[i] *= n;
                    }
                    return this;
                }
            },
            sum: {
                value: function () {
                    if (typeof this[0] === "number") return this.reduce((s, p) => s + p);
                    return this[0].add(...this.splice(1, this.length - 1));
                }
            },
            last: {
                get: function () {
                    return this[this.length - 1]
                }
            },
            clone: {
                get: function () {
                    const a = [];
                    for (let i in this) a[i] = this[i];
                    return a;
                }
            }
        });
        function sum(k, n, fn) {
            return new Array(n - k + 1).fill(0).map((i, j) => fn(j)).sum()
        }
        function binomialcoefs(n) {
            if (n === 0) return [1]
            const previous = binomialcoefs(n - 1);
            return [1, ...new Array(n - 1).fill(0).map((e, i) => previous[i] + previous[i + 1]), 1];
        }
        function BezierCurve(...pts) {
            this.pts = pts;
            this.n = pts.length - 1;
            this.cs = binomialcoefs(this.n);
            this.fn = a => (b = 1 - a, sum(0, this.n, i => this.pts[i].clone.multiply(this.cs[i] * a ** i * b ** (this.n - i))));
            this.getPoints = n => new Array(n).fill(0).map((i, j) => this.fn((j + 1) / n))
        }
        function Line(A, B) {
            this.pts = [A, B];
            this.getPoints = n => (console.log(this.pts), [this.pts[1]])
        }
        var run = () => {
            str2 = '';
            if (points.length === 0) return
            const v = [...points[0], ...points[0]]
            for (let i in points) {
                point = points[i]
                console.log(i, point)
                if (v[0] > point[0]) v[0] = point[0]
                else if (v[2] < point[0]) v[2] = point[0]
                if (v[1] > point[1]) v[1] = point[1]
                else if (v[3] < point[1]) v[3] = point[1];
                str2 += (i !== "0" ? ' L ' : 'M ') + point[0] + ',' + point[1];
            }
            console.log(points)
            v[2] -= v[0];
            v[3] -= v[1];
            svg.setAttribute('viewBox', `${v.join(' ')}`)
            path.setAttribute('d', str2 + ' z');
        }
        String.prototype.splice = function (index, rem, str) {
            return this.slice(0, index) + str + this.slice(index + Math.abs(rem));
        };
        function numbertoSTL(n) {
            if (n === 0) return '0.00000E+000';
            const s = Math.sign(n)
            var k = 0
            if (s === 1) {
                while (n >= 10 ** k) k++
                while (n < 10 ** k) k--
            } else {
                while (n > -(10 ** k)) k--
                while (n <= -(10 ** k)) k++
            }
            if (s === -1) k--
            n *= 10 ** -k
            n = (Math.round(n * 1e5) * 1e-5).toString()
            if (n.length === (s === -1 ? 2 : 1))
                n += '.00000';
            else
                for (let i = n.length; i < (s === -1 ? 8 : 7); i++)
                    n += '0';
            var k_txt = Math.abs(k).toString()
            for (let i = k_txt.length; i < 3; i++) k_txt = '0' + k_txt;
            return `${n.slice(0, (s === -1 ? 8 : 7))}E${k < 0 ? '-' : '+'}${k_txt}`
        }
        const vertexText = point => `            vertex ${point.map(numbertoSTL).join(' ')}`;
        const vertexText_xxx = point => `            vertex ${point.join(' ')}`;
        const txt0 = numbertoSTL(0);
        const txtm = numbertoSTL(-1);
        const txt1 = numbertoSTL(1);
        // function turn_points(txtH) {
        //     return points.map(([x, y]) => (txtX = numbertoSTL(x), txtY = numbertoSTL(y), [x, y, vertexText_xxx([txtX, txtY, txtH]), vertexText_xxx([txtX, txtY, txt0])]))
        // }
        function fetch_points() {
            const matrix = [];
            for (let i = 0; i < points.length; i++) {
                matrix[i] = [];
                pt = points[i];
                for (let j = 0; j < rotate_precision; j++) {
                    matrix[i][j] = [[Math.cos(j*Math.PI*2/rotate_precision)*pt[0],Math.sin(j*Math.PI*2/rotate_precision)*pt[0],pt[1]]];
                    // console.log(matrix[i][j][0])
                    matrix[i][j][1] = vertexText(matrix[i][j][0]);
                }
            }
            return matrix;
        }
        function crossProduct(v, u) {
            return [v[1] * u[2] - v[2] * u[1], v[2] * u[0] - v[0] * u[2], v[0] * u[1] - v[1] * u[0]]
        }
        function normalVector(A, B, C) {
            return crossProduct([A[0] - B[0], A[1] - B[1], A[2] - B[2]], [A[0] - C[0], A[1] - C[1], A[2] - C[2]])
        }
        function toSTL() {
            var str = `solid svgobject\n`
            const t = "    ";
            const mat = fetch_points()
            console.log(mat)
            for (let i = 0; i < points.length-1; i++) {
                for (let j = 0; j < rotate_precision; j++) {
                    const A = mat[i][j], 
                        B = mat[i][(j+1)%rotate_precision], 
                        C = mat[i+1][j],
                        D = mat[i+1][(j+1)%rotate_precision];
                    str += `${t}facet normal ${normalVector(A[0],B[0],C[0]).map(numbertoSTL).join(' ')}\n${t+t}outer loop\n${A[1]}\n${B[1]}\n${C[1]}\n${t+t}endloop\n${t}endfacet\n`
                    str += `${t}facet normal ${normalVector(C[0],B[0],D[0]).map(numbertoSTL).join(' ')}\n${t+t}outer loop\n${C[1]}\n${B[1]}\n${D[1]}\n${t+t}endloop\n${t}endfacet\n`
                }
            }
            str += `endsolid svgobject`;
            return str;
        }
        function readSVG(str, scale = 1) {
            const sp = str.split(/[\s,]+/);
            const divide = [];
            var i = 0;
            var relativity;
            var type = "";
            while (i < sp.length) {
                if (isNaN(sp[i])) {
                    type = sp[i].toLowerCase();
                    relativity = type === sp[i];
                    i++;
                } else {
                    const pt = relativity ? divide.last?.last || [0, 0] : [0, 0];
                    switch (type) {
                        case "m":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])].multiply(scale)]);
                            type = "l"
                            i += 2;
                            break;
                        case "l":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])].multiply(scale).add(pt)]);
                            i += 2;
                            break;
                        case "h":
                            // console.log(pt.clone, divide.clone, relativity)
                            divide.push([[Number(sp[i]) * scale + pt[0], divide.last?.last?.[1] || 0]]);
                            i += 1;
                            break;
                        case "v":
                            divide.push([[divide.last?.last?.[0] || 0, Number(sp[i]) * scale + pt[1]]]);
                            i += 1;
                            break;
                        case "c":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])], [Number(sp[i + 2]), Number(sp[i + 3])], [Number(sp[i + 4]), Number(sp[i + 5])]].map(e => e.multiply(scale).add(pt)));
                            i += 6;
                            break;
                        case "q":
                            divide.push([[Number(sp[i]), Number(sp[i + 1])], [Number(sp[i + 2]), Number(sp[i + 3])]].map(e => e.multiply(scale).add(pt)));
                            i += 4;
                            break;
                    }
                }
            }
            console.log(divide)
            lines = [];
            for (let i = 1; i < divide.length; i++) {
                if (divide[i].length === 1) {
                    lines[i - 1] = new Line(divide[i - 1].last, ...divide[i]);
                } else {
                    lines[i - 1] = new BezierCurve(divide[i - 1].last, ...divide[i]);
                }
            }
            console.log(divide.last.last, divide[0][0])
            lines[divide.length - 1] = new Line(divide.last.last, divide[0][0]);
            return lines;
        }
        onkeydown = (e) => {
            const { key, ctrlKey, shiftKey } = e;
            if (ctrlKey) {
                if (key.toLowerCase() === 's') {
                    e.preventDefault()
                    const a = document.createElement('a');
                    // console.log(toSTL())
                    a.href = 'data:image/svg+xml;utf-8,' + encodeURIComponent(toSTL());
                    a.download = `path.stl`;
                    a.click();
                }
                if (key.toLowerCase() === 'e') {
                    e.preventDefault()
                    str = prompt('str', str) || str;
                    readSVG(str, Number(prompt("current scale: (number)", 0.26458333) || 1));
                    precision = Number(prompt('precision', precision) || precision);
                    console.log(lines.map(l => l.getPoints(precision)))
                    points = Array.prototype.concat(...lines.map(l => l.getPoints(precision)))
                    run()
                }
            }
        }
        run()
    </script>
</body>

</html>